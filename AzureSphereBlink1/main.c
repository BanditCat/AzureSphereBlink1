#define WIFICONFIG_STRUCTS_VERSION 1

#include "TinyPngOut.h"
#include "base64.h"

#include <stdbool.h>
#include <errno.h>
#include <string.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <sys/time.h>
#include <ctype.h>

#include <applibs/log.h>
#include <applibs/gpio.h>
#include <applibs/networking.h>
#include <applibs/wificonfig.h>

void myWrite(int cfd, const char* things[], int* lens, int numThings ) {
	for (int i = 0; i < numThings; ++i) {
		int timesWaited = 0;
		size_t done = 0;
		size_t end = strlen(things[i]);
		while (1) {
			if (done == end)
				break;
			int ret = write(cfd, things[i] + done, end - done);
			if (ret && ret != -1) {
				timesWaited = 0;
				done += ret;
			}
			if (timesWaited++ > 100)
				break;
			const struct timespec sleepTime = { 0, 10000000 };
			nanosleep(&sleepTime, NULL);
		}
		if (timesWaited > 100)
			break;
	}
}

void die(const char* arg) {
	Log_Debug(
		"Error %s: %s (%d). Dying!.\n",
		arg, strerror(errno), errno);
	exit(-1);
}

int websock = -1;

// Zooming
double xs = -3.0,ys = -3.0;
double xe = 3.0,ye = 3.0;

// Colors
int numColors = 3;
unsigned char reds[] = { 0,255,0 };
unsigned char greens[] = { 0,255,255 };
unsigned char blues[] = { 0,255,128 };
unsigned char hexColor[] = "#000000";
const unsigned char hexString[] = "0123456789ABCDEF";

void tick( int btnA, int btnB, int red1, int green1, int blue1 ) {

	struct sockaddr_un peer_addr;
	int peer_addr_size = sizeof(struct sockaddr_un);
	int cfd = accept4(websock, (struct sockaddr*) &peer_addr,
		&peer_addr_size, SOCK_NONBLOCK | SOCK_CLOEXEC);
	if (cfd == -1) {
		if (!(errno == EAGAIN || errno == EWOULDBLOCK))
			die("accept");
	}
	
	else {
		GPIO_SetValue(red1, GPIO_Value_Low);
		GPIO_SetValue(green1, GPIO_Value_High);
		GPIO_SetValue(blue1, GPIO_Value_High);
		char buf[2048] = { 0 };
	
		int timesWaited = 0;
		while(1){
			if( read(cfd, buf, 2040) > 4 )
				break;
			if (timesWaited++ > 100)
				break;
			const struct timespec sleepTime = { 0, 10000000 };
			nanosleep(&sleepTime, NULL);
		}
		if (timesWaited > 100) {
			close(cfd);
			return;
		}

		char getn[256];
		char* p = buf + 4;
		char* p2 = getn;
		while (*p != ' ' && (p2-getn < 250)) 
			*p2++ = *p++;
		*p2 = '\0';
		Log_Debug("Requested %s\n", getn);
		if (!strcmp("/favicon.ico", getn)) {
			const unsigned char rawData[1150] = {
				0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x10, 0x10, 0x00, 0x00, 0x01, 0x00,
				0x20, 0x00, 0x68, 0x04, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x28, 0x00,
				0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00,
				0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0xC3, 0x0E,
				0x00, 0x00, 0xC3, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xE2, 0xE2,
				0xE2, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4,
				0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4,
				0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4,
				0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0xF1, 0xF1,
				0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF, 0x82, 0x82,
				0x82, 0xFF, 0x3C, 0x3C, 0x3C, 0xFF, 0x3C, 0x3C, 0x3C, 0xFF, 0x3C, 0x3C,
				0x3C, 0xFF, 0x3F, 0x3F, 0x3F, 0xFF, 0x40, 0x40, 0x40, 0xFF, 0x3F, 0x3F,
				0x3F, 0xFF, 0x3F, 0x3F, 0x3F, 0xFF, 0x3F, 0x3F, 0x3F, 0xFF, 0x3E, 0x3E,
				0x3E, 0xFF, 0x3C, 0x3C, 0x3C, 0xFF, 0x3C, 0x3C, 0x3C, 0xFF, 0x3C, 0x3C,
				0x3C, 0xFF, 0x82, 0x82, 0x82, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF, 0xE2, 0xE2,
				0xE2, 0xFF, 0x3D, 0x3D, 0x3D, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x02, 0x02,
				0x02, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x02, 0x02,
				0x02, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x3D, 0x3D, 0x3D, 0xFF, 0xE2, 0xE2,
				0xE2, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0x3C, 0x3C, 0x3C, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x06, 0x06, 0x06, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x47, 0x47,
				0x47, 0xFF, 0xAA, 0xAA, 0xAA, 0xFF, 0xB1, 0xB1, 0xB1, 0xFF, 0xB1, 0xB1,
				0xB1, 0xFF, 0xAA, 0xAA, 0xAA, 0xFF, 0x47, 0x47, 0x47, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x06, 0x06, 0x06, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x3C, 0x3C,
				0x3C, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0x3C, 0x3C,
				0x3C, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x02, 0x02, 0x02, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFD,
				0xFD, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD0, 0xD0,
				0xD0, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x02, 0x02, 0x02, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x3C, 0x3C, 0x3C, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4,
				0xE4, 0xFF, 0x3C, 0x3C, 0x3C, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x05, 0x05,
				0x05, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x62, 0x62, 0x62, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xF9, 0xF9, 0xF9, 0xFF, 0xF9, 0xF9, 0xF9, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0x62, 0x62, 0x62, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x05, 0x05,
				0x05, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x3C, 0x3C, 0x3C, 0xFF, 0xE4, 0xE4,
				0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0x3C, 0x3C, 0x3C, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x02, 0x03, 0x02, 0xFF, 0x03, 0x03, 0x03, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x75, 0x75, 0x75, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0x75, 0x75, 0x75, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x03, 0x03,
				0x03, 0xFF, 0x02, 0x02, 0x03, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x3C, 0x3C,
				0x3C, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0x3C, 0x3C,
				0x3C, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x04, 0x0A, 0x04, 0xFF, 0x03, 0x0C,
				0x03, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x0A, 0x0B, 0x0A, 0xFF, 0xE1, 0xE1,
				0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF, 0x0A, 0x0A, 0x0A, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x03, 0x02, 0x0C, 0xFF, 0x03, 0x03, 0x0A, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x3C, 0x3C, 0x3C, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE5,
				0xE4, 0xFF, 0x3C, 0x3B, 0x3C, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x09, 0xC0,
				0x08, 0xFF, 0x06, 0xDB, 0x05, 0xFF, 0x04, 0x15, 0x05, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x1A, 0x1C, 0x1B, 0xFF, 0x1B, 0x1A, 0x1C, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x04, 0x03, 0x14, 0xFF, 0x03, 0x03, 0xD8, 0xFF, 0x06, 0x05,
				0xBE, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x3C, 0x3C, 0x3B, 0xFF, 0xE4, 0xE4,
				0xE5, 0xFF, 0xE4, 0xE7, 0xE4, 0xFF, 0x3B, 0x31, 0x3B, 0xFF, 0x00, 0x2D,
				0x00, 0xFF, 0x04, 0xFF, 0x04, 0xFF, 0x01, 0xFF, 0x00, 0xFF, 0x05, 0x59,
				0x04, 0xFF, 0x05, 0x03, 0x13, 0xFF, 0x01, 0x06, 0x03, 0xFF, 0x03, 0x01,
				0x05, 0xFF, 0x14, 0x08, 0x00, 0xFF, 0x03, 0x02, 0x59, 0xFF, 0x00, 0x01,
				0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0x00, 0x00, 0x2D, 0xFF, 0x3B, 0x3B,
				0x30, 0xFF, 0xE4, 0xE4, 0xE7, 0xFF, 0xE4, 0xE6, 0xE4, 0xFF, 0x3B, 0x35,
				0x3B, 0xFF, 0x00, 0x16, 0x00, 0xFF, 0x07, 0xF7, 0x09, 0xFF, 0x02, 0xF9,
				0x00, 0xFF, 0x0C, 0x95, 0x5D, 0xFF, 0x0A, 0xFB, 0xFF, 0xFF, 0x00, 0x6D,
				0x6B, 0xFF, 0x6F, 0x20, 0x23, 0xFF, 0xFF, 0x6B, 0x60, 0xFF, 0x5B, 0x26,
				0x60, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x07, 0x05, 0xF5, 0xFF, 0x00, 0x00,
				0x16, 0xFF, 0x3B, 0x3B, 0x35, 0xFF, 0xE4, 0xE4, 0xE6, 0xFF, 0xE4, 0xE4,
				0xE4, 0xFF, 0x3C, 0x3D, 0x3C, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x07, 0x52,
				0x09, 0xFF, 0x07, 0x52, 0x00, 0xFF, 0x08, 0xAF, 0xB5, 0xFF, 0x00, 0xFF,
				0xFF, 0xFF, 0x02, 0xC7, 0xC7, 0xFF, 0xCB, 0x4F, 0x50, 0xFF, 0xFF, 0x70,
				0x72, 0xFF, 0xB5, 0x4C, 0x48, 0xFF, 0x00, 0x00, 0x59, 0xFF, 0x08, 0x06,
				0x50, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x3C, 0x3C, 0x3D, 0xFF, 0xE4, 0xE4,
				0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0x3D, 0x3C, 0x3D, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x03, 0x06, 0x07, 0xFF, 0x02, 0x00, 0x00, 0xFF, 0x0B, 0x92,
				0x92, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x00, 0xA2, 0xA2, 0xFF, 0xA8, 0x3A,
				0x3A, 0xFF, 0xFF, 0x7C, 0x7D, 0xFF, 0x92, 0x3C, 0x3D, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x07, 0x05, 0x04, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x3C, 0x3C,
				0x3C, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0x3D, 0x3D,
				0x3D, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x02, 0x03, 0x03, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x00, 0x0F, 0x10, 0xFF, 0x01, 0x65, 0x65, 0xFF, 0x00, 0x16,
				0x16, 0xFF, 0x18, 0x03, 0x03, 0xFF, 0x64, 0x23, 0x24, 0xFF, 0x10, 0x05,
				0x05, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x03, 0x02, 0x02, 0xFF, 0x00, 0x00,
				0x00, 0xFF, 0x3D, 0x3D, 0x3D, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF, 0xF3, 0xF3,
				0xF3, 0xFF, 0x82, 0x82, 0x82, 0xFF, 0x3C, 0x3C, 0x3C, 0xFF, 0x3C, 0x3C,
				0x3C, 0xFF, 0x3C, 0x3D, 0x3D, 0xFF, 0x3B, 0x39, 0x39, 0xFF, 0x3B, 0x29,
				0x29, 0xFF, 0x3C, 0x38, 0x38, 0xFF, 0x37, 0x3B, 0x3B, 0xFF, 0x29, 0x34,
				0x34, 0xFF, 0x39, 0x3B, 0x3B, 0xFF, 0x3D, 0x3C, 0x3C, 0xFF, 0x3C, 0x3C,
				0x3C, 0xFF, 0x3C, 0x3C, 0x3C, 0xFF, 0x82, 0x82, 0x82, 0xFF, 0xF3, 0xF3,
				0xF3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xE2, 0xE2,
				0xE2, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE5,
				0xE5, 0xFF, 0xE4, 0xE9, 0xE9, 0xFF, 0xE4, 0xE5, 0xE5, 0xFF, 0xE5, 0xE4,
				0xE4, 0xFF, 0xE9, 0xE6, 0xE6, 0xFF, 0xE5, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4,
				0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0xF1, 0xF1,
				0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
			};
			{
				const unsigned char *msg2 = "HTTP/2.0 200 OK\ncontent-type:image/x-icon\n\n";
				const char* things[] = { msg2,rawData };
				const int thingLens[] = { strlen(msg2),1150 };
				myWrite(cfd, things, thingLens, (sizeof(things) / sizeof(things[0])));
			}
	
			close(cfd);

		}
		else {
			if (strcmp(getn, "/unzoom") == 0) {
				double midx = (xe + xs) * 0.5;
				double midy = (ye + ys) * 0.5;
				double span = (xe - xs);
				xs = midx - span;
				xe = midx + span;
				ys = midy - span;
				ye = midy + span;
			}else if (strncmp(getn, "/zoomX", 5) == 0) {
				int c = 0;
				int k = 0;
				char xa[5], ya[5];
				while (c < 4 && isdigit(getn[c + 6])) {
					xa[c] = getn[c + 6];
					++c;
				}
				xa[c] = 0;
				while (k < 4 && isdigit(getn[c + 7 + k])) {
					ya[k] = getn[c + 7 + k];
					++k;
				}
				ya[k] = 0;
				double xz = atoi(xa) / 399.0;
				double yz = atoi(ya) / 399.0;
				double midx = (xe - xs) * xz + xs;
				double midy = (ye - ys) * yz + ys;
				double span = (xe - xs) / 4;
				xs = midx - span;
				xe = midx + span;
				ys = midy - span;
				ye = midy + span;
				Log_Debug("Zooming %f,%f\n", xz, yz);
			}
			const int width = 200;
			const int height = 200;
			const int buf2size = width*height*4;

			char *buf2 = malloc( buf2size );
			FILE* tf;
			if( NULL == (tf = fmemopen(buf2, buf2size, "r+") ))
				die("fmemopen");
			struct TinyPngOut tpo;
			if (TinyPngOut_init(&tpo, width, height, tf) != TINYPNGOUT_OK)
				die("TPOinit");
			unsigned char *img = malloc( width*3 );
			for (int y = 0; y < height; ++y){
				for (int x = 0; x < width; ++x) {
					double cr = ((double)x / (width - 1)) * (xe - xs) + xs;
					double ci = ((double)y / (height - 1)) * (ye - ys) + ys;
					double xr = cr;
					double xi = ci;
					double iter = 0.0;
					double minxr = 1000.0;
					double minyr = 1000.0;
					for (int i = 0; i < 1024; ++i) {
						double t = xr;
						xr = xr * xr - xi * xi + cr;
						xi = 2 * xi * t + ci;
						if (fabs(xr) < minxr) {
							minxr = fabs(xr);
						}
						if (fabs(xi) < minyr) {
							minyr = fabs(xi);
						}
						if ((xr * xr + xi * xi) > 4.0) {
							break;
						}
						iter++;

					}
					unsigned char red = sin(log(minxr)) * 128.0 + 128.0;
					unsigned char green = sin(log(minyr)) * 128.0 + 128.0;;
					unsigned char blue = sin(iter / 200.0) * 128 + 128;
					if (x == width / 2 && y == height / 2) {
						reds[2] = red;
						greens[2] = green;
						blues[2] = blue;
						reds[1] = red;
						greens[1] = green;
						blues[1] = blue;
						hexColor[1] = hexString[red >> 4];
						hexColor[2] = hexString[red & 15];
						hexColor[3] = hexString[green >> 4];
						hexColor[4] = hexString[green & 15];
						hexColor[5] = hexString[blue >> 4];
						hexColor[6] = hexString[blue & 15];
						Log_Debug("hexcolor %s\n", hexColor);
					}
					img[x * 3 + 0] = red;
					img[x * 3 + 1] = green;
					img[x * 3 + 2] = blue;
					
				}

				int out;
				if ((out = TinyPngOut_write(&tpo, img, width)) != TINYPNGOUT_OK) {
					char msg[] = "0 is the tinypng error";
					msg[0] = '0' + out;
					die(msg);
				}
			}
			free(img);
			size_t sz = ftell(tf);
			fseek(tf, 0L, SEEK_SET);
			size_t outs;
			unsigned char *pngmsg = base64_encode(buf2, sz, &outs);
			fclose(tf);
			free(buf2);

			const char* out1 =
				"HTTP/2.0 200 OK\n"
				"content-type:text/html;charset=UTF-8\n"
				"\n"
				"<!DOCTYPE html>\n"
				"<html>\n"
				"<head>\n"
				"<title>Fancy pixel picker</title>\n"
				"</head>\n"
				"<body>\n"
				"<h1>Click below to zoom</h1>\n"
				"<p>Fancy LED color picker written by Jon DuBois.</p>\n"
				"<img onclick=\"window.location.assign('zoomX'+event.offsetX+'Y'+event.offsetY);\" width='400px' height='400px' src='data:image/png;base64,";
			const char* out2 =
				"'/>\n"
				"<p></p><button onclick=\"window.location.assign('unzoom');\"><h1>Unzoom</h1></button>\n"
				"<p></p><table bgcolor = '";
			const char* out3 =
				"'><tr><td><font color='#FFFFFF'><h1>LED ";
			const char* out4 = 
				"</h1></font></td></tr></table>\n"
				"</body>\n"
				"</html>\n";
			const char* things[] = { out1,pngmsg,out2,hexColor,out3,hexColor,out4 };
			const int thingLens[] = { strlen(out1),strlen(pngmsg),strlen(out2),strlen(hexColor),strlen(out3),strlen(hexColor),strlen(out4) };
			myWrite(cfd, things, thingLens, (sizeof(things) / sizeof(things[0])));
			free(pngmsg);
			close(cfd);
		}
	}

	static float speed = 1.0;
	static float red, green, blue;
	static unsigned int rnd;
	static float nr, ng, nb;
	GPIO_Value_Type ov, ov2;
	GPIO_GetValue(btnA, &ov);
	GPIO_GetValue(btnB, &ov2);
	if (ov == GPIO_Value_Low && speed > 0.0001 ){
		speed -= 0.00007;
	}
	if (ov2 == GPIO_Value_Low && speed < 10.0 ) {
		speed += 0.00007;
	}

	static int whichColor = 0;
	if ( !(int)(nr - red) && !(int)(green - ng) && !(int)(blue - nb)) {
		whichColor++;
		if (whichColor >= numColors)
			whichColor = 0;
		nr = reds[whichColor];
		nb = blues[whichColor];
		ng = greens[whichColor];
	}
	else {
		red = red + (nr - red) * 0.001 * speed;
		green = green + (ng - green) * 0.001 * speed;
		blue = blue + (nb - blue) * 0.001 * speed;
	}

	rnd = (rnd * 1103515245 + 12345) & 2147483647;
	if (((rnd >> 0) & 255) < red) {
		GPIO_SetValue(red1, GPIO_Value_Low);
	}
	else {
		GPIO_SetValue(red1, GPIO_Value_High);
	}
	if (((rnd >> 8) & 255) < green) {
		GPIO_SetValue(green1, GPIO_Value_Low);
	}
	else {
		GPIO_SetValue(green1, GPIO_Value_High);
	}
	if (((rnd >> 16) & 255) < blue) {
		GPIO_SetValue(blue1, GPIO_Value_Low);
	}
	else {
		GPIO_SetValue(blue1, GPIO_Value_High);
	}
}
int main(void)
{

	int btnA = GPIO_OpenAsInput(12);
	int btnB = GPIO_OpenAsInput(13);
	int fd = GPIO_OpenAsOutput(8, GPIO_OutputMode_PushPull, GPIO_Value_High);
	int fd2 = GPIO_OpenAsOutput(9, GPIO_OutputMode_PushPull, GPIO_Value_High);
	int fd3 = GPIO_OpenAsOutput(10, GPIO_OutputMode_PushPull, GPIO_Value_High);
	if (btnA < 0 || fd < 0 || fd2 < 0 || fd3 < 0) {
		die("GPIO");
	}
	
	{
		Networking_NetworkInterface nis[5];
		do {
			Networking_GetInterfaces(nis, 5);
			Log_Debug("IC: %s\n\n", nis[0].interfaceName);
		} while (!nis[0].isEnabled);


#include "C://root/wifipass.c"
		for (int i = 0; i < numWifis; ++i)
			if (WifiConfig_StoreWpa2Network(wifis[ i ], strlen(wifis[i]), wifiPasses[i], strlen(wifiPasses[i]))== -1)
				if (errno != EEXIST)
					die("Wifi failed");
		
		WifiConfig_ConnectedNetwork wcn;	
		if( WifiConfig_GetCurrentNetwork(&wcn) == -1 )
			die( "wifi2" );


		struct sockaddr_un my_addr;

		websock = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK , /* protocol */ 0);
		if (websock < 0) 
			die("socket");

		int enableReuseAddr = 1;
		int r = setsockopt(websock, SOL_SOCKET, SO_REUSEADDR, &enableReuseAddr,
			sizeof(enableReuseAddr));
		if (r != 0) 
			die("setsockopt/SO_REUSEADDR");
		struct linger sli = { 0,0 };
		if (0 != setsockopt(websock, SOL_SOCKET, SO_LINGER, &sli, sizeof( sli )))
			die("SO_LINGER");

		// Bind to a well-known IP address.
		struct sockaddr_in addr;
		memset(&addr, 0, sizeof(addr));
		addr.sin_family = AF_INET;
		addr.sin_port = htons(11000);

		int er = bind(websock, (const struct sockaddr*) & addr, sizeof(addr));
		if (er != 0) {
			die("bind");
		}
		if (listen(websock, /* backlog size */ 50) == -1)
			die("listen");


	}

    const struct timespec sleepTime = {0, 10000};
    while (true) {
		tick( btnA, btnB, fd, fd2, fd3 );
		nanosleep(&sleepTime, NULL);
    }
}